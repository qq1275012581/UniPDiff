import netCDF4
import numpy as np
from datetime import datetime
from torchvision import transforms
import torch
from datetime import date, timedelta

def save_to_nc(data, out_time_list, filename='output.nc'):
    """
    将形状为 [T, 721, 1440] 的 numpy 数组保存为 NetCDF 文件。
    
    参数：
      data: numpy 数组，形状为 [T, 721, 1440]，T为时间维度
      out_time_list: 时间字符串列表，格式为 'YYYY-MM-DDTHH:MM:SS'，例如：
                     ['2024-06-01T06:00:00', '2024-07-01T06:00:00', '2024-08-01T06:00:00']
      filename: 输出的 nc 文件名，默认为 'output.nc'
    """
    # 创建 NetCDF 文件
    ncfile = netCDF4.Dataset(filename, mode='w', format='NETCDF4')
    
    # 创建维度
    ncfile.createDimension('time', data.shape[0])
    ncfile.createDimension('lat', data.shape[1])
    ncfile.createDimension('lon', data.shape[2])
    
    # 创建坐标变量
    time_var = ncfile.createVariable('time', np.float64, ('time',))
    lat_var = ncfile.createVariable('lat', np.float32, ('lat',))
    lon_var = ncfile.createVariable('lon', np.float32, ('lon',))
    
    # 创建主要数据变量
    data_var = ncfile.createVariable('data', np.float32, ('time', 'lat', 'lon'))
    
    # 添加全局属性
    ncfile.description = 'NetCDF file created from numpy array'
    ncfile.history = 'Created ' + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    ncfile.source = 'Generated by save_to_nc function'
    
    # 设置经纬度坐标（这里示例生成均匀分布的经纬度，实际数据可根据需要调整）
    latitudes = np.linspace(90, -90, data.shape[1])
    longitudes = np.linspace(0, 360, data.shape[2])
    lat_var[:] = latitudes
    lon_var[:] = longitudes
    
    # 定义时间单位，例如：从1970-01-01 00:00:00开始的小时数
    time_units = 'hours since 1970-01-01 00:00:00'
    # 将输入的时间字符串转换为 datetime 对象
    time_datetimes = [datetime.strptime(t, '%Y-%m-%dT%H:%M:%S') for t in out_time_list]
    # 将 datetime 对象转换为数值形式
    time_var[:] = netCDF4.date2num(time_datetimes, units=time_units)
    time_var.units = time_units
    
    # 写入数据变量
    data_var[:, :, :] = data
    
    # 关闭文件
    ncfile.close()
    print("NetCDF file saved as", filename)

def save_to_nc_month(data, out_time_list, filename='output.nc'):
    """
    将形状为 [T, month, 721, 1440] 的 numpy 数组保存为 NetCDF 文件，
    其中 month 维度的值固定为 [6, 7, 8]。
    
    参数：
      data: numpy 数组，形状为 [T, month, 721, 1440]，T为时间维度
      out_time_list: 时间字符串列表，格式为 'YYYY-MM-DDTHH:MM:SS'，例如：
                     ['2024-06-01T06:00:00', '2024-07-01T06:00:00', '2024-08-01T06:00:00']
      filename: 输出的 nc 文件名，默认为 'output.nc'
    """
    # 创建 NetCDF 文件
    ncfile = netCDF4.Dataset(filename, mode='w', format='NETCDF4')
    
    # 创建维度
    ncfile.createDimension('time', data.shape[0])
    ncfile.createDimension('month', data.shape[1])  # 此处应为3
    ncfile.createDimension('lat', data.shape[2])
    ncfile.createDimension('lon', data.shape[3])
    
    # 创建坐标变量
    time_var = ncfile.createVariable('time', np.float64, ('time',))
    month_var = ncfile.createVariable('month', np.int32, ('month',))
    lat_var = ncfile.createVariable('lat', np.float32, ('lat',))
    lon_var = ncfile.createVariable('lon', np.float32, ('lon',))
    
    # 创建主要数据变量
    data_var = ncfile.createVariable('data', np.float32, ('time', 'month', 'lat', 'lon'))
    
    # 添加全局属性
    ncfile.description = 'NetCDF file created from numpy array'
    ncfile.history = 'Created ' + datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    ncfile.source = 'Generated by save_to_nc function'
    
    # 设置经纬度坐标（示例中生成均匀分布的经纬度，实际数据可根据需要调整）
    latitudes = np.linspace(90, -90, data.shape[2])
    longitudes = np.linspace(0, 360, data.shape[3])
    lat_var[:] = latitudes
    lon_var[:] = longitudes
    
    # 设置 month 坐标，固定为 [6, 7, 8]
    month_var[:] = np.array([6, 7, 8])
    
    # 定义时间单位，例如：从1970-01-01 00:00:00开始的小时数
    time_units = 'hours since 1970-01-01 00:00:00'
    # 将输入的时间字符串转换为 datetime 对象
    time_datetimes = [datetime.strptime(t, '%Y-%m-%d') for t in out_time_list]
    # 将 datetime 对象转换为数值形式
    time_var[:] = netCDF4.date2num(time_datetimes, units=time_units)
    time_var.units = time_units
    
    # 写入数据变量
    data_var[:, :, :, :] = data
    
    # 关闭文件
    ncfile.close()
    print("NetCDF file saved as", filename)


import pandas as pd
def generate_time_matrix(end_date, num_days=31, lookback_days=30):
    """
    生成一个时间矩阵：
    - 从指定的结束日期往前数 num_days 天（包括结束日期）。
    - 对于这 num_days 天中的每一天，再分别往前数 lookback_days 天（包括当天）。
    - 最终返回一个维度为 (num_days, lookback_days) 的时间矩阵。

    参数:
        end_date (str): 结束日期，格式为 'YYYY-MM-DD'
        num_days (int): 从结束日期往前数的天数，默认为 31 天。
        lookback_days (int): 每个日期往前数的天数，默认为 30 天。

    返回:
        list: 一个维度为 (num_days, lookback_days) 的时间矩阵。
    """
    # 从结束日期往前数 num_days 天（包括结束日期）
    main_date_range = pd.date_range(start=end_date, periods=num_days, freq='-1D')

    # 初始化时间矩阵
    time_matrix = []

    # 对于每一天，再往前数 lookback_days 天（包括当天）
    for date in main_date_range:
        time_list = pd.date_range(start=date, periods=lookback_days, freq='-1D').strftime('%Y-%m-%d').tolist()
        time_matrix.append(time_list)

    return time_matrix

def generate_summer_dates(start_year, end_year):
    """
    生成每年6月、7月和8月的日期，按 (years, months, days) 的结构组织。

    参数:
        start_year (int): 开始年份
        end_year (int): 结束年份

    返回:
        list: 一个三维列表，结构为 (years, months, days)
    """
    summer_dates = []

    for year in range(start_year, end_year + 1):
        year_dates = []  # 存储当前年份的日期
        for month in [6, 7, 8]:  # 遍历6月、7月和8月
            # 生成当前月份的日期范围
            start_date = f"{year}-{month:02d}-01"
            end_date = f"{year}-{month:02d}-{pd.Timestamp(year, month, 1).daysinmonth}"
            month_dates = pd.date_range(start=start_date, end=end_date).strftime('%Y-%m-%d').tolist()
            year_dates.append(month_dates)
        summer_dates.append(year_dates)

    return summer_dates

import xarray as xr
import numpy as np
import os

def extract_summer_precipitation(start_year, end_year, data_dir, variable_name='tp'):
    """
    提取每年6月、7月和8月的降水数据，并使用 np.stack 组合成一个 NumPy 数组。

    参数:
        start_year (int): 开始年份
        end_year (int): 结束年份
        data_dir (str): 存放.nc文件的目录路径
        variable_name (str): nc文件中降水数据的变量名，默认为 'tp'

    返回:
        numpy.ndarray: 三维数组，结构为 (years, months, days)，包含每年6-8月的降水数据。
    """
    all_years_data = []

    for year in range(start_year, end_year + 1):
        # 构造文件路径
        file_path = os.path.join(data_dir, f"era5.total_precipitation.{year}.nc")
        
        # 检查文件是否存在
        if not os.path.exists(file_path):
            print(f"File not found: {file_path}")
            continue
        
        # 打开.nc文件
        ds = xr.open_dataset(file_path)
        
        # 提取6月、7月和8月的数据
        year_data = []
        for month in [6, 7, 8]:
            # 筛选特定月份的数据
            monthly_data = ds[variable_name].sel(valid_time=ds['valid_time'].dt.month == month)
            # 提取每天的数据
            daily_data = monthly_data.groupby('valid_time.day').mean().values  # 转换为 NumPy 数组
            year_data.append(daily_data)
        
        # 将当前年份的数据添加到列表中
        all_years_data.append(year_data)
        ds.close()
    
    # 使用 np.stack 将所有年份的数据组合成一个三维数组
    summer_precipitation = np.stack(all_years_data, axis=0)
    
    return summer_precipitation

def normlize(data):
    return torch.log(1+data/1e-5)

def transformNorm(data, is_train=False):
    if is_train:
        std, mean = np.load("/share/home/liguowen/ClimaX/data/ERA5/0.25deg/daily/tp/1990_2019_std_mean.npy")
    else:
        std, mean = np.load("/share/home/liguowen/ClimaX/data/ERA5/0.25deg/daily/tp/2020_2024_std_mean.npy")
    data_normalize = transforms.Normalize(mean=mean, std=std)
    return data_normalize(data)

def transformDenorm(data, is_train=False):
    if is_train:
        std, mean = np.load("/share/home/liguowen/ClimaX/data/ERA5/0.25deg/daily/tp/1990_2019_std_mean.npy")
    else:
        std, mean = np.load("/share/home/liguowen/ClimaX/data/ERA5/0.25deg/daily/tp/2020_2024_std_mean.npy")
    mean_denorm, std_denorm = -mean / std, 1 / std
    data_normalize = transforms.Normalize(mean=mean_denorm, std=std_denorm)
    return data_normalize(data)

def denormlize(data):
    return (torch.exp(data)-1) * 1e-5

def get_jan15_to_feb15(year: int):
    """
    给定一个年份，返回该年从1月15日到2月15日的32天日期列表。
    
    参数:
        year (int): 输入的年份
        
    返回:
        List[date]: 从1月15日到2月15日的日期列表（包含两端，共32个日期）
    """
    start_date = date(year, 1, 15)
    end_date = date(year, 2, 15)
    delta = end_date - start_date  # timedelta对象，表示两日期间隔（这里为31天）
    
    # 生成包含起始日期到结束日期的所有日期，注意要加上1天以包含结束日期
    dates = [(start_date + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(delta.days + 1)]
    return dates

# 示例使用
if __name__ == '__main__':
    # 构造一个示例数据数组，假设有3个时间点，每个时刻的数组为 721x1440
    # example_data = np.random.rand(3, 721, 1440)
    # out_time_list = ['2024-06-01T06:00:00', '2024-07-01T06:00:00', '2024-08-01T06:00:00']
    # save_to_nc(example_data, out_time_list, filename='example.nc')

    # 示例：以 2024-03-01 为结束日期，往前数 31 天，每一天再往前数 30 天
    # 示例：以 2024-03-01 为结束日期，往前数 31 天，每一天再往前数 30 天
    # 示例：获取2020年到2025年每年6-8月的日期
    # 示例：提取2020年到2025年的数据
    # start_year = 2020
    # end_year = 2025
    # data_dir = "/share/home/liguowen/ClimaX/data/ERA5/0.25deg/daily/tp/"  # 替换为存放.nc文件的目录路径

    # # 提取数据
    # summer_precipitation = extract_summer_precipitation(start_year, end_year, data_dir)

    # # 打印结果
    # print("Shape of the precipitation array:", summer_precipitation.shape)
    year = 2024
    date_list = get_jan15_to_feb15(year)
    for d in date_list:
        print(d)
